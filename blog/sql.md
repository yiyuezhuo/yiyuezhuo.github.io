# 数据库三大范式

# 第一范式 凡是能输入到数据库软件中的表都是符合第一范式的，不符合第一范式的指的是表的嵌套结构。解决这个问题的方式是将嵌套结构摊开在一个表或者“展开”成另一个表。

# 第二范式

## 函数依赖 

若给定X的值，可以推断出Y的值（这里及下面的大写字母均表示属性组），即不存在这样的情况，X相同而Y不相同。则称Y函数依赖于X

### 完全（正好/最小依赖）

Y依赖X，但并不依赖于X的任何真子集，则Y完全依赖于X

### 部分（冗余）依赖

Y依赖X，但并不完全依赖于X，即存在X真子集使Y依赖/完全依赖。

### 传递函数依赖

若Z依赖于Y，Y依赖于X，则Z依赖于X的关系是传递函数依赖

## 码

若除K以外的列都完全依赖于K，则K是候选码。一般在候选码中指定一个主码。

注意函数依赖达成的一个平凡条件是被依赖集不重复，既然不重复自然其他列怎么取都不可能出现违反定义的情况。所以主关键字列一般都是平凡的码。

### 主属性与非主属性

对于表中码的一种选定，码内的属性是主属性，码外的属性是非主属性。

### 范式判定

表符合第二范式，如果有非主属性对于码有部分函数依赖。（遍历所有候选码，只要存在就不满足第二范式）

### 何谓不是第二范式

违反了第二范式意味着存在分拆的可能，如直接把部分依赖的列和残码创建一个新表，同时删除原表中部分依赖的列（残码不删除）。注意这样变换起码会使新表比以前的对应部分规模下降，因为可以删除残码相同而残码补不同的行。从实际意义来看，这意味着一些“实体”分离出去储存更符合逻辑。

## 第三范式

对于所有码，不存在非主属性对码的传递函数依赖。

传递函数依赖意味着存在其他集可以单独确定另一个集，但其他集本身并不足以成为码。这时我们进一步把这种“部分码”也按上面的方式分离出去移除这种情况就可以满足第三范式。

可以看出三大范式推进的时候都致力于把确定性实体分离出去，因为如果X可以成为码，那么X在对象中一般代表对象本身，而其他非主属性可以看出对象的属性。我们所做的就是不断划分出这些对象。

## BCNF范式

表不存在一个码下的主属性对另一个码下的主属性的部分和传递函数依赖。

最简单的情况，存在多个类似主关键字列的东西于一张表中。